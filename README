Alpha Release

Erlang API for CouchDB and at the same time transactions on top of CouchDB by 
using mnesia. More or less, cdberl adds CouchDB as a backend to mnesia with 
it's benefits: scalable, reliable, large storage and so on. At the same time 
some of CouchDB:s MVCC benefits are 'lost' e.g the replication part and 
revision control.

Of course the cdberl library can be used directly with CouchDB for simple access 
and by inserting records right into CouchDB.

Background:
	- needed new backend for current DBMS. (dets has it's limitations like a 
		2GB limit per table)
	- needed ACID transactions and locking.
	- chosing mnesia with mnesiaex would lead to a transparent layer and the 
		current implementation wouldn't need so much refactoring


Dependencies:
Erlang/OTP R12B-5
CouchDB 0.90 and newer
Mnesiaex  http://code.google.com/p/mnesiaex/


Installation
* Install Mnesiaex - there are an excellent tutorial on it's site
* Install CouchDB
* Install cdberl:
	Put the cdberl lib in a path accessible by erlang either with:
		erl -pa <path-to-cdberl/ebin>
	or just put cdberl in erlang/lib/. Compile with:
		erlc -o ebin src/*.erl  

		
Observe: In CoudhDB there are no tables just databases, but I call it tables 
	and uses it as tables 
	
What will work:
- transactions
- locks 
- ordinary mnesia-calls in a transaction context and as dirty_operations 
	(read, write, create_table, delete_table, info, table-iterations (as last, first, prev, next and all_keys) and more).
- views, by looking at them as dirty operations
- record to json, json to record-conversion - look at the bottom of this doc.
		
		
What will work with some ad_hoc-modifications of the code:
- 	mnesia:select, 
	mnesia:index_read and 
	mnesia:match_object if you catch a 
	specific call to them in cdb_tab and sending the query to a CouchDB view - 
	ad_hoc.
- 'complex datatypes' as port, pid, funs, >32bit integers, floats and so on 
   needs some modification of the code in order to work due to impedance mismatch 
  (they need to be encoded as a base64-string or similar, or tagged up like the 
   tuple-type).

What doesn't work:
- the same stuff that isn't working with Mnesiaex 
	http://code.google.com/p/mnesiaex/wiki/Overview
- dynamic queries like mnesia:select or mnesia:match_object without 
	changing cdb_tab
- revision control (are ignored due to the pessimistic currency control of 
	mnesia)

Not yet implemented/TODO (a taste of):
- Proper distribution. Right now the location of the server isn't stored in 
	mnesia's schema.
- The revision cache aren't cleared so it can grow out of control (really easy 
	to do but is there need for it?). 
- Index/view creatin from mnesia. The views must be added manually, can be easily 
	added when creating a table.
- Replication via mnesia. The replication hasn't been touched at all and there's
	no code for it in cdberl atm  
		

Misc information
- cdberl communicates with CouchDB via HTTP by using the erlang_couchdb module
- for now cdb_com assumes that there are one, and only one, design document in 
	a table. Otherwise the functionality of mnesia:first/last is broken but 
	with some modification of cdb_com:first and cdb_com:last that can be 
	ignored.
- the doc._id is for now a base64 representation of the record key but that can
	be changed
- In a mnesia transaction, writing to the backend is made _after_ a commit 
	message has been written to the transaction log. This implies that if 
	CouchDB (or DETS) goes down in the middle of doing some writes, mnesia still 
	regards the transaction as a successful one.
- for more information check inline documentation or send me a message!


- to add a table we sometimes need to add cases to the following functions:
	
	cdb_doc:rec_to_doc/2  * 
	cdb_doc:doc_to_rec/2  *
	cdb_util:default_vals/1 **
	cdb_util:encode_key/2 ***  
	cdb_util:decode_key/2 ***
	
	* only needs to be implemented if there are special "terms" that collide with	
	  json types and javascript inbuilt types. I.e
	  integers > 32bit will be converted to floats upon insertion in database and
	  converted back to integer when reading the value. That leads 
	  to the implication that integers with more than ~16 digits will be converted
	  to float and truncated when converting back to integer. It also leads to the 
	  fact that floats cannot be stored in database unless special implementation 
	  in cdb_doc:doc_to_rec and rec_to_doc is done.

	** if don't want to use mnesia you can access couchdb with cdberl directly but 
	   then you need to specify the default-values for the record in 
	   cdb_util:default_vals/1 otherwise you will get an exception.
	   
	*** if you aren't happy that a doc._id is a base64 term of your record key 
		then you can use encode_key and decode_key to implement your own 
		encoder/decoder
	

Example:
Erlang (BEAM) emulator version 5.6.5 [source] [64-bit] [smp:4] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.6.5  (abort with ^G)

(rc@sillhaj)1> cdberl:start().
ok

(rc@sillhaj)2> mnesia:start().
ok

(rc@sillhaj)3> mnesia:change_table_copy_type (schema, node (), disc_copies).
{atomic,ok}

%% create a table
(rc@sillhaj)4>mnesia:create_table(testtable,[{ type, { external, ordered_set, cdb_tab } }, { external_copies, [ node () ]}]).
{atomic,ok}

%% read and write a record
(rc@sillhaj)5>mnesia:dirty_write({testtable, foo, {an_atom, 1234, "string", {tuple}}),  mnesia:dirty_read(testtable, foo).
[{testtable,foo,bar}]

%% a simple write test, only for fun
(rc@sillhaj)6>f (), Start = now (), [ mnesia:dirty_write ({ testtab, N, N }) || N <- lists:seq (1, 10000) ], End = now (), timer:now_diff (End, Start).
38335037

%% a simple read test, only for fun
(rc@sillhaj)7>f (), Start = now (), [ mnesia:dirty_read(testtable, N) || N <- lists:seq (1, 10000) ] ,End = now (), timer:now_diff (End, Start).
11970713

%% writing and reading some Erlang terms:
(rc@sillhaj)8> Record = {testtable, term_test, [an_atom, "a_list", {a_tuple}, 1234567890, ["a_complex",{[42],{[42]}},-1234567890]]}.
ok
(rc@sillhaj)9>mnesia:dirty_write(Record). 
ok
(rc@sillhaj)10>[Record] =:= mnesia:dirty_read(testtable, term_test).
true

(rc@sillhaj)15> mnesia:info().
---> Processes holding locks <---
---> Processes waiting for locks <---
---> Participant transactions <---
---> Coordinator transactions <---
---> Uncertain transactions <---
---> Active tables <---
testtable      : with 10002    records occupying 5553469  words of mem
schema         : with 3        records occupying 651      words of mem
===> System info in version "4.4.7.6", debug level = none <===
opt_disc. Directory "/home/cardell/development/git/cdberl/Mnesia.nonode@nohost" is used.
use fallback at restart = false
running db nodes   = [nonode@nohost]
stopped db nodes   = []
master node tables = []
remote             = []
ram_copies         = []
disc_copies        = [schema]
disc_only_copies   = []
external_copies    = [testtable]
[{nonode@nohost,disc_copies}] = [schema]
[{nonode@nohost,{external_copies,cdb_tab}}] = [testtable]
4 transactions committed, 0 aborted, 0 restarted, 1 logged to disc
0 held locks, 0 in queue; 0 local transactions, 0 remote
0 transactions waits for other nodes: []
ok


^C
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
a


Some screenshots in the download section
More examples in src/examples.erl



-  How to represent Erlang terms in JSON.
	Hard nut to crack due to impedance mismatch: e.g no objects in Erlang and 
		no tuples, atoms or large integers in JSON. Tuples and large integers 
		was the hardest problem and	has no pretty solution. I've left the 
		integer part so it just works with some of my tables but clearly it is 
		not ready.

	    Erlang tem		<->					JSON
		List, "123"							Array, [49,50,51]
		Tuple, {1,2,3}						JSON object, {"tuple": [1,2,3]}
		Atom, foo							JSON string, "foo"	
		Float								N/A					TODO
		Fun									N/A
		N/A									JSON object
		Big Integer > ~2^53					Float, truncated, 	TODO
		Medium Integer	2^32< X < 2~53		Float				TODO
		Small Integer < 2^32				Integer 			TODO


- To change the default-sever location check cdberl.app or change it by calling
	cdb_srv:set_server(Tablename, {server, "http://it.uu.se", 5984}) 
	or cdb_srv:set_server(default, {server, "http://it.uu.se", 5984}).

